#include <miracl/miracl.h>
#include <miracl/mirdef.h>

int main() {
    // 初始化Miracl系统
    miracl* mip = mirsys(5000, 16);
    mip->IOBASE = 16;
    clock_t start, end;
    double sum = 0.0;
    // 定义椭圆曲线参数和点G的坐标
    char* p_str = "FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF7FFFFFFF";
    char* a_str = "FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF7FFFFFFC";
    char* b_str = "1C97BEFC54BD7A8B65ACF89F81D4D4ADC565FA45";
    char* gx_str = "4A96B5688EF573284664698968C38BB913CBFC82";
    char* gy_str = "23A628553168947D59DCC912042351377AC5FB32";

    // 转换这些参数为大数
    big p = mirvar(0);
    big a = mirvar(0);
    big b = mirvar(0);
    big gx = mirvar(0);
    big gy = mirvar(0);

    cinstr(p, p_str);
    cinstr(a, a_str);
    cinstr(b, b_str);
    cinstr(gx, gx_str);
    cinstr(gy, gy_str);

    ecurve_init(a, b, p, MR_BEST); // 初始化椭圆曲线
    epoint* G = epoint_init();     // 初始化基点G

    if (!epoint_set(gx, gy, 1, G)) { // 设置基点G
        fprintf(stderr, "Error setting point G.\n");
        return 1;
    }

    // 这里应当设置你的标量k值，例如通过输入或者某个算法计算得到
    big k = mirvar(0);
    // 你需要根据实际情况来设置这个k值
    cinstr(k, "314062C910DF14CE473D6A568E7CF60A3CFB8B0A");

    epoint* result = epoint_init(); // 初始化点乘运算结果的点
    for (int i = 0; i < 1; i++) {
        start = clock();
        ecurve_mult(k, G, result);     // 执行点乘运算 k*G
        end = clock();

        time = double(end - start) / CLOCKS_PER_SEC;
        sum = sum + time;
    }
    printf("%lf", sum / 1);

    big rx = mirvar(0);
    big ry = mirvar(0);
    epoint_get(result, rx, ry); // 获取结果点的坐标

    // 输出结果
    printf("Resulting point coordinates:\n");
    cotstr(rx, mip->IOBUFF);
    printf("X: %s\n", mip->IOBUFF);
    cotstr(ry, mip->IOBUFF);
    printf("Y: %s\n", mip->IOBUFF);

    // 清理资源
    mirkill(p);
    mirkill(a);
    mirkill(b);
    mirkill(gx);
    mirkill(gy);
    mirkill(rx);
    mirkill(ry);
    mirkill(k);
    epoint_free(G);
    epoint_free(result);
    mirexit();

    return 0;
}
	


	

